using System;
using System.Collections.Generic;
using AnimatingHair.Entity.PhysicalEntity;
using OpenTK;

using AnimatingHair.Auxiliary;

namespace AnimatingHair.Entity
{
    class Hair
    {
        public float H1, H2;

        public HairParticle[] Particles = new HairParticle[ Const.HairParticleCount ];
        public ParticlePair[ , ] ParticlePairs = new ParticlePair[ Const.HairParticleCount, Const.HairParticleCount ];
        public List<ParticlePair> ParticlePairsIteration = new List<ParticlePair>();

        private float[] alpha_r = new float[ Const.HairParticleCount ];
        private float[] alpha_t = new float[ Const.HairParticleCount ];

        public float Kernel0H2;

        public void CalculateForcesOnSelf()
        {
            prepareParticles();

            prepareParticlePairs();

            //calculateTIJ();   // TODO: ???

            applyGravitationalForce();

            applySpringForces();

            applyNeighborForces();

            applyAirFrictionForces();

            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle hp = Particles[ i ];

                if ( hp.IsRoot )
                {
                    hp.Force = Vector3.Zero;
                }
            }
        }

        public void CalculateDensity()
        {
            for ( int index = 0; index < Particles.Length; index++ )
            {
                HairParticle particle = Particles[ index ];

                float sum = particle.Mass * Kernel0H2;

                for ( int i = 0; i < particle.NeighborsHair.Count; i++ )
                {
                    sum += particle.NeighborsHair[ i ].Mass * particle.KernelH2DistancesHair[ i ];
                }

                particle.Density = sum;
            }
        }

        public void UpdateDirections()
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                updateDirection( Particles[ i ] );
            }
        }

        public Vector3 CenterPosition()
        {
            Vector3 sum = Vector3.Zero;

            for ( int i = 0; i < Particles.Length; i++ )
            {
                sum += Particles[ i ].Position;
            }

            return sum / Const.HairParticleCount;
        }

        private void prepareParticlePairs()
        {
            for ( int i = 0; i < ParticlePairsIteration.Count; i++ )
            {
                ParticlePair pp = ParticlePairsIteration[ i ];

                pp.Alpha = findAlphaIJ( pp.Particle1.ID, pp.Particle2.ID );
                pp.T = findTIJ( pp );
            }
        }

        private void prepareParticles()
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle hp = Particles[ i ];

                hp.Force = Vector3.Zero;

                calculateNewKX( hp );

                calculateAlphas( hp );
            }
        }

        private void applyGravitationalForce()
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle particle = Particles[ i ];
                particle.Force.Y += particle.Mass * (-Const.Gravity);
            }
        }

        private void applyAirFrictionForces()
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle hp = Particles[ i ];

                Vector3 direction = hp.Velocity;
                float velocityMagnitude = direction.Length;

                if ( velocityMagnitude < 0.000001 )
                    continue;

                direction = direction / velocityMagnitude; // normalize

                hp.Force -= (Const.AirFriction * velocityMagnitude) * direction;
            }
        }

        private void applyNeighborForces()
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle particle = Particles[ i ];

                for ( int j = 0; j < particle.NeighborsHair.Count; j++ )
                {
                    Vector3 f = calculateHairHairForces(
                        particle, particle.NeighborsHair[ j ],
                        particle.DistancesHair[ j ], particle.KernelH2DistancesHair[ j ] );
                    particle.Force += f;
                }
            }
        }

        private static Vector3 calculateHairHairForces( HairParticle hpI, HairParticle hpJ, float distance, float kernelH2 )
        {
            Vector3 x_ij = hpJ.Position - hpI.Position;
            Vector3 v_ij = hpJ.Velocity - hpI.Velocity;

            Vector3 d_n = Vector3.Cross( hpI.Direction, hpJ.Direction );
            float d_n_length = d_n.Length;
            if ( d_n_length < 0.05 ) // NOTE: konstanta
            {
                d_n = x_ij - (Vector3.Dot( x_ij, hpI.Direction ) * hpI.Direction);
                d_n.Normalize();
            }
            else
            {
                d_n /= d_n_length;
            }

            // ATTRACTION/REPULUSION FORCE
            float P_i = Const.k_a * (hpI.Density - Const.rho_0);
            float P_j = Const.k_a * (hpJ.Density - Const.rho_0);

            Vector3 wgrad = KernelEvaluator.ComputeKernelGradientH2( hpI.Position - hpJ.Position, distance );
            float d1 = P_i / (hpI.Density * hpI.Density);
            float d2 = P_j / (hpJ.Density * hpJ.Density);
            Vector3 f_a = -hpI.Mass * hpJ.Mass * (d1 + d2) * wgrad;

            // COLLISION FORCE
            Vector3 f_c = Vector3.Zero;
            float sign = (Vector3.Dot( x_ij, d_n ) * Vector3.Dot( v_ij, d_n ));
            if ( sign < 0 )
                f_c = Const.d_c * kernelH2 * Vector3.Dot( v_ij, d_n ) * d_n;

            // FRICTION FORCE
            Vector3 f_f = Vector3.Zero;
            Vector3 d_t = v_ij - (Vector3.Dot( v_ij, d_n ) * d_n);
            if ( !(d_t.X < 0.00001 && d_t.X < 0.00001 && d_t.X < 0.00001) ) //NOTE: konstanta
            {
                d_t.Normalize();
                f_f = Const.d_f * kernelH2 * (Vector3.Dot( v_ij, d_t ) * d_t);
            }

            return f_a + f_c + f_f;
        }

        private static Vector3 findTIJ( ParticlePair pp )
        {
            Vector3 x_ijNormalized = pp.X;
            x_ijNormalized.Normalize();

            Vector3 axis = Vector3.Cross( pp.Particle1.Direction, x_ijNormalized );

            return Geometry.RotateVectorAroundAxis( x_ijNormalized, axis, pp.Theta );
        }

        private void updateDirection( HairParticle hp )
        {
            Vector3 sum = Vector3.Zero;

            for ( int i = 0; i < hp.NeighborsRoot.Count; i++ )
            {
                ParticlePair pp = ParticlePairs[ hp.ID, hp.NeighborsRoot[ i ].ID ];
                sum += pp.Alpha * pp.K * pp.T;
            }

            for ( int i = 0; i < hp.NeighborsTip.Count; i++ )
            {
                ParticlePair pp = ParticlePairs[ hp.ID, hp.NeighborsTip[ i ].ID ];
                sum += pp.Alpha * pp.K * pp.T;
            }

            sum.Normalize();

            hp.Direction = float.IsNaN( sum.X ) ? Vector3.Zero : sum;
        }

        private void calculateAlphas( HairParticle hp )
        {
            float numerator = Const.E * hp.Area;
            float denominator = 0;

            for ( int i = 0; i < hp.NeighborsRoot.Count; i++ )
            {
                ParticlePair pp = ParticlePairs[ hp.ID, hp.NeighborsRoot[ i ].ID ];
                denominator += pp.L * pp.K;
            }
            if ( denominator != 0 )
                alpha_r[ hp.ID ] = numerator / denominator;

            denominator = 0;
            for ( int i = 0; i < hp.NeighborsTip.Count; i++ )
            {
                ParticlePair pp = ParticlePairs[ hp.ID, hp.NeighborsTip[ i ].ID ];
                denominator += pp.L * pp.K;
            }
            if ( denominator != 0 )
                alpha_t[ hp.ID ] = numerator / denominator;
        }

        private void applySpringForces()
        {
            for ( int i = 0; i < ParticlePairsIteration.Count; i++ )
            {
                ParticlePair pp = ParticlePairsIteration[ i ];

                Vector3 deltaLocation = pp.Particle2.Position - pp.Particle1.Position;
                float distance = deltaLocation.Length;
                deltaLocation.Normalize();

                float springCoefficient = pp.Alpha * pp.K;
                float springFactor = springCoefficient * (distance - pp.L);
                Vector3 force = springFactor * deltaLocation;

                pp.Particle1.Force += force;
            }
        }

        private float findAlphaIJ( int i, int j )
        {
            if ( belongsTo( Particles[ i ], Particles[ j ].NeighborsTip ) &&
                belongsTo( Particles[ j ], Particles[ i ].NeighborsRoot ) )
            {
                return (alpha_r[ i ] + alpha_t[ j ]) / 2;
            }

            if ( belongsTo( Particles[ i ], Particles[ j ].NeighborsRoot ) &&
                belongsTo( Particles[ j ], Particles[ i ].NeighborsTip ) )
            {
                return (alpha_r[ j ] + alpha_t[ i ]) / 2;
            }

            return 0;
        }

        private static bool belongsTo( HairParticle hp, List<HairParticle> list )
        {
            int x = list.BinarySearch( hp );
            Console.WriteLine( x );
            return list.Contains( hp ); // TODO: usorti si na zaciatku neighborsRoot&List a rob binary search
        }

        private void calculateNewKX( HairParticle hp )
        {
            Vector3 x_ij;
            float l;

            for ( int i = 0; i < hp.NeighborsRoot.Count; i++ )
            {
                HairParticle neighbor = hp.NeighborsRoot[ i ];

                ParticlePair currentPair = ParticlePairs[ hp.ID, neighbor.ID ];

                x_ij = neighbor.Position - hp.Position;
                l = x_ij.Length;
                currentPair.X = x_ij;
                currentPair.XLength = l;

                currentPair.K = currentPair.C * KernelEvaluator.ComputeKernelH1( l );
            }

            for ( int i = 0; i < hp.NeighborsTip.Count; i++ )
            {
                HairParticle neighbor = hp.NeighborsTip[ i ];

                ParticlePair currentPair = ParticlePairs[ hp.ID, neighbor.ID ];

                x_ij = neighbor.Position - hp.Position;
                l = x_ij.Length;
                currentPair.X = x_ij;
                currentPair.XLength = l;

                currentPair.K = currentPair.C * KernelEvaluator.ComputeKernelH1( l );
            }
        }

        public void RKStep( int stepNumber )
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle particle = Particles[ i ];
                if ( !particle.IsRoot )
                    particle.RKStep( stepNumber );
            }
        }

        internal void ApplyInertialAcceleration( Vector3 acceleration )
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle particle = Particles[ i ];
                if ( !particle.IsRoot )
                    particle.Force += particle.Mass * acceleration;
            }
        }

        internal void ApplyInertialAngularAcceleration( float acceleration )
        {
            for ( int i = 0; i < Particles.Length; i++ )
            {
                HairParticle particle = Particles[ i ];
                if ( !particle.IsRoot )
                    particle.ApplyAngularAcceleration( acceleration );
            }
        }
    }
}
